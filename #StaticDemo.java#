/*
静态：static
用法：是一个修饰符，用于修饰成员（成员变量和成员函数）
当成员被静态修饰后就多了一种调用方式，除了可以被对象调用外，还可以直接被类名调用
格式是 类名.静态成员
static 的特点：
1，随着类的加载而加载
	也就是说静态会随着类的消失而消失，也就是说它的生命周期最长
2，优先于对象存在
	明确一点：静态是先存在的，对象是后存在的
3，被所有对象所共享
4，可以直接被类名调用

实例变量和类变量的区别
1，存放位置
	类变量随着类的加载存在于方法区中，
	实例变量随着对象的建立而存在于堆内存中
2，生命周期：
	类变量生命周期最长，随着类的消失而消失
	实例变了的生命周期随着对象的消失而消失

静态的使用注意事项：
	1，静态方法只能访问静态成员。因为，非静态成员在对象中，可能未被创建
		非静态方法既可以访问静态也可以访问非静态
	2，静态方法中不可以定义this，super关键字
		因为静态优先于对象存在，所以静态方法中部可以出现this
	3，主函数是静态的

主函数：是一个特殊的函数，作为函数的入口，可以被jvm调用

主函数的定义：
public：代表着该函数访问权限很大
static：代表主函数随着类的加载就已经存在了
void：主函数没有具体的返回值
main：不是关键字，但是是一个特殊的单词，可以被jvm识别。
函数的参数：（String[] args）：参数类型是一个数组，该数组是字符串型的数组

主函数的格式是固定的：jvm识别。
jvm在调用主函数的时候，传入的时new String[0]；
在用命令行运行StaticDemo时，可以同时传入参数   java StaticDemo haha   即将haha存入args



静态有利有弊
利：对对象的共享数据进行单独空间的存储，节省空间。没有必要每个对象中都有一个存储备份
	可以被类名调用
弊：生命周期过长。
	访问出现局限性。（只能访问静态）

什么时候使用静态？
因为静态修饰的内容是成员变量和函数

什么时候定义静态的变量（类变量）？
当对象中出现共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态存在于堆内存中

什么时候定义静态函数？
当功能内部没有访问到非静态数据（对象的特有数据）
那么该功能可以定义为静态的
	可以这么理解：对象的出现是封装数据的，如果成员函数没有访问非静态成员
					那么就没必要再通过new方法来新建对象而调用方法，所以可以直接通过静态函数访问

*/
/*
特有内容随着对象存在堆内存中，即name存在对象所在堆中
而static 修饰的country则存在方法区（共享区，数据区）
*/
class Person
{
	String name;//成员变量，也叫实例变量
	static String country="CN";//静态成员变量，也叫类变量
	public void show()
	{
		System.out.println(name+"::::"+country);
	}
}


class StaticDemo  
{
	public static void main(String[] args) 
	{
		System.out.println(args);//[Ljava.lang.String;@55e55f
		//当成员被静态修饰后就多了一种调用方式，除了可以被对象调用外，还可以直接被类名调用
		//	格式是 类名.静态成员
		System.out.println(Person.country);
		Person p=new Person();
		p.show();
		//静态的应用
		int[] arrs={3,6,8,12};
		//ArrayTool at=new ArrayTool();
		//System.out.println(at.getMax(arrs));
		System.out.println(ArrayTool.getMax(arrs));
	}
	
}

	
